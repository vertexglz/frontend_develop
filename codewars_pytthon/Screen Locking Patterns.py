'''
Шаблоны блокировки экрана
Возможно, вы уже знакомы со многими смартфонами, которые позволяют использовать геометрический узор в качестве меры безопасности. Чтобы разблокировать устройство, вам нужно соединить последовательность точек/точек в сетке, проведя пальцем, не отрывая его, пока вы проводите узор по экрану.

На изображении ниже показан пример узора из 7 точек/точек: (A -> B -> I -> E -> D -> G -> C).

lock_example.png

Для этого ката ваша задача — реализовать функцию, которая возвращает количество возможных узоров, начинающихся с заданной первой точки, которые имеют заданную длину.

В частности, для функции countPatternsFrom(firstPoint, length) параметр firstPoint — это односимвольная строка, соответствующая точке в сетке (например, «A»), где начинаются ваши узоры, а параметр length — это целое число, указывающее количество точек (длину), которые должен иметь каждый узор.

Например, countPatternsFrom("C", 2) должен возвращать количество шаблонов, начинающихся с 'C', которые имеют 2 две точки. Возвращаемое значение в этом случае будет 5, поскольку существует 5 возможных шаблонов:

(C -> B), (C -> D), (C -> E), (C -> F) и (C -> H).

Помните, что эта ката требует возврата количества шаблонов, а не самих шаблонов, поэтому вам нужно только подсчитать их. Кроме того, название функции может отличаться в зависимости от используемого языка программирования, но идея остается той же.

Правила
В шаблоне точки/точки не могут повторяться: они могут быть использованы только один раз, максимум.

В шаблоне любые две последовательные точки/точки могут быть соединены только прямыми прямыми линиями одним из следующих способов:

Горизонтально: как (A -> B) в примере изображения шаблона.
Вертикально: как (D -> G) в примере изображения шаблона.
По диагонали: как (I -> E), а также (B -> I) в примере изображения шаблона.
Проход через точку между ними, которая уже была «использована»: как (G -> C), проходя через E, в примере изображения шаблона. Это самое хитрое правило. Обычно вы не сможете соединить G с C, потому что E находится между ними, однако, когда E уже используется как часть шаблона, который вы трассируете, вы можете соединить G с C, минуя E, потому что E игнорируется, так как он уже использовался один раз.

В примерах тестов есть несколько примеров количества комбинаций для некоторых случаев, которые помогут вам проверить ваш код.

Примечание Haskell: вместо односимвольных строк предоставляется тип данных Vertex. Подробнее см. в коде настройки решения.

Интересный факт:

Если вам интересно из любопытства, для экрана блокировки Android допустимые шаблоны должны иметь от 4 до 9 точек/точек. Всего существует 389112 возможных допустимых шаблонов; то есть узоры длиной от 4 до 9 точек/пунктов.
'''


'''Решение'''

def count_patterns_from(first_point, length):
    # Проверка корректности входных данных
    if length < 1 or length > 9:
        return 0
    
    # Сетка точек
    grid = 'ABCDEFGHI'
    
    # Правила перемещения между точками (точки, которые блокируют переход)
    blocked_moves = {
        'A': {'C': 'B', 'G': 'D', 'I': 'E'},
        'B': {'H': 'E'},
        'C': {'A': 'B', 'G': 'E', 'I': 'F'},
        'D': {'F': 'E'},
        'E': {},
        'F': {'D': 'E'},
        'G': {'A': 'D', 'C': 'E', 'I': 'H'},
        'H': {'B': 'E'},
        'I': {'A': 'E', 'C': 'F', 'G': 'H'}
    }
    
    # Начальная точка
    start_index = grid.index(first_point)
    
    # Отслеживание посещенных точек
    visited = [False] * 9
    visited[start_index] = True
    
    # Рекурсивная функция подсчета путей
    def backtrack(current_point, current_length):
        # Если достигли нужной длины пароля
        if current_length == length:
            return 1
        
        # Счетчик путей
        count = 0
        
        # Перебираем все возможные точки
        for i in range(9):
            # Пропускаем уже использованные точки
            if not visited[i]:
                next_point = grid[i]
                
                # Проверяем правила перемещения
                blocked = blocked_moves[current_point].get(next_point)
                
                # Можно перейти, если нет блокировки или блокирующая точка уже посещена
                if blocked is None or visited[grid.index(blocked)]:
                    # Отмечаем точку как посещенную
                    visited[i] = True
                    
                    # Рекурсивный вызов для следующей точки
                    count += backtrack(next_point, current_length + 1)
                    
                    # Возвращаем состояние дляbacktracking
                    visited[i] = False
        
        return count
    
    # Запускаем подсчет путей
    return backtrack(first_point, 1)
